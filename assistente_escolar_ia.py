#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üéì ASSISTENTE ESCOLAR IA - SUPABASE EDITION
==========================================

Assistente inteligente para gest√£o escolar usando Supabase como backend.
- ‚úÖ OpenAI Function Calling integrado com Supabase
- ‚úÖ Identifica√ß√£o autom√°tica de respons√°veis n√£o cadastrados  
- ‚úÖ Filtragem avan√ßada por turma, nome e outros crit√©rios
- ‚úÖ Cadastro inteligente de respons√°veis e alunos
- ‚úÖ Vincula√ß√£o autom√°tica de relacionamentos

üëâ Uso:
    python assistente_escolar_ia.py
"""

import os
import json
import asyncio
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv
from executor_unificado import executar_function
from datetime import datetime

# üå± Carregar vari√°veis de ambiente
load_dotenv()

# üîë Configura√ß√£o da OpenAI
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    print("‚ö†Ô∏è OPENAI_API_KEY n√£o encontrada no arquivo .env")
    print("üí° Para usar IA, adicione sua chave OpenAI no arquivo .env")
    print("üí° Voc√™ ainda pode usar as fun√ß√µes manualmente")

try:
    from openai import OpenAI
    client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None
except ImportError:
    print("‚ö†Ô∏è OpenAI n√£o instalado. Execute: pip install openai")
    client = None
except Exception as e:
    print(f"‚ùå Erro ao inicializar OpenAI: {e}")
    client = None

# ==========================================================
# üîß Carregar Tools
# ==========================================================

def load_tools() -> List[Dict[str, Any]]:
    """Carrega tools do functions.json"""
    try:
        with open("functions.json", encoding="utf-8") as f:
            data = json.load(f)
            tools = data["tools"]
            
            print(f"‚úÖ Carregadas {len(tools)} fun√ß√µes")
            return tools
    except Exception as e:
        print(f"‚ùå Erro ao carregar functions.json: {e}")
        return []

# ==========================================================
# üß† Sistema de Prompt Avan√ßado
# ==========================================================

SYSTEM_PROMPT = """
üéì Voc√™ √© um Assistente Escolar IA especializado em gest√£o educacional.

üéØ MISS√ÉO:
- Analisar extratos PIX e identificar respons√°veis n√£o cadastrados
- Gerenciar alunos, respons√°veis e relacionamentos no Supabase
- Facilitar cadastros e vincula√ß√µes de forma inteligente
- Fornecer relat√≥rios e an√°lises financeiras educacionais

‚ö° CAPACIDADES ESPECIAIS:
- Identifica√ß√£o autom√°tica de respons√°veis n√£o cadastrados no extrato PIX
- Filtragem avan√ßada por turma, nome, aus√™ncia de dados
- Cadastro inteligente com valida√ß√£o de dados
- Vincula√ß√£o autom√°tica de relacionamentos familiares
- An√°lise contextual de padr√µes de pagamento

üîß DIRETRIZES DE EXECU√á√ÉO:
1. Sempre confirme antes de cadastrar ou modificar dados importantes
2. Use m√∫ltiplas fun√ß√µes quando necess√°rio para obter contexto completo
3. Forne√ßa resumos claros ap√≥s opera√ß√µes complexas
4. Identifique e sugira corre√ß√µes para dados inconsistentes
5. Mantenha foco na experi√™ncia do usu√°rio educacional

üìä PADR√ïES DE RESPOSTA:
- Portugu√™s brasileiro profissional e acess√≠vel
- Emojis para clareza visual e organiza√ß√£o
- Tabelas e listas organizadas para dados
- Confirma√ß√µes antes de a√ß√µes cr√≠ticas
- Sugest√µes proativas baseadas em an√°lises

üí° INTELIG√äNCIA CONTEXTUAL:
- Identifique padr√µes de nomes similares entre respons√°veis e alunos
- Detecte inconsist√™ncias em dados de matr√≠cula e vencimento
- Sugira relacionamentos familiares baseados em nomes
- Analise padr√µes de pagamento para identificar anomalias

üîê SEGURAN√áA:
- Nunca modifique dados sem confirma√ß√£o expl√≠cita
- Valide CPFs, datas e outros dados cr√≠ticos
- Mantenha privacidade de informa√ß√µes sens√≠veis
"""

# ==========================================================
# ü§ñ Assistente Escolar IA
# ==========================================================

class AssistenteEscolarIA:
    def __init__(self, use_ai: bool = True):
        self.tools = load_tools()
        self.conversation_history = []
        self.use_ai = use_ai and client is not None
        self.max_history = 25  # Controle de contexto aumentado para melhor sequ√™ncia
        
        # Valida√ß√£o das ferramentas
        if not self.tools:
            raise ValueError("‚ùå Nenhuma ferramenta carregada. Verifique functions.json")
            
        print(f"üöÄ Assistente inicializado com {len(self.tools)} ferramentas")
        if not self.use_ai:
            print("‚ö†Ô∏è Modo manual ativado (sem IA)")

    def add_to_history(self, role: str, content: str):
        """Adiciona mensagem ao hist√≥rico da conversa"""
        self.conversation_history.append({
            "role": role,
            "content": content
        })
        
        # Mant√©m apenas as √∫ltimas mensagens
        if len(self.conversation_history) > self.max_history:
            self.conversation_history = self.conversation_history[-self.max_history:]

    def format_welcome_message(self) -> str:
        """Mensagem de boas-vindas personalizada"""
        ai_status = "‚úÖ IA ATIVADA" if self.use_ai else "‚ö†Ô∏è MODO MANUAL"
        
        return f"""
üéì **ASSISTENTE ESCOLAR IA - SUPABASE EDITION**
==============================================

{ai_status}

üöÄ **FUNCIONALIDADES PRINCIPAIS:**
- üîç Identificar respons√°veis n√£o cadastrados no extrato PIX
- üë• Gerenciar alunos e respons√°veis com filtros avan√ßados
- üîó Vincular relacionamentos familiares automaticamente
- üìä Analisar estat√≠sticas financeiras e educacionais
- üìù Cadastrar novos alunos e respons√°veis

üí° **COMANDOS INTELIGENTES:**
‚Ä¢ "Liste respons√°veis do extrato PIX n√£o cadastrados"
‚Ä¢ "Mostre alunos da turma Infantil III sem data de matr√≠cula" 
‚Ä¢ "Cadastre respons√°vel Jo√£o Silva como pai do aluno Maria Silva"
‚Ä¢ "Analise estat√≠sticas do extrato PIX"
‚Ä¢ "Processe automaticamente respons√°veis n√£o cadastrados"

üéØ **COMANDOS MANUAIS:**
‚Ä¢ 'menu' - Mostrar menu de fun√ß√µes
‚Ä¢ 'ajuda' - Mostrar comandos dispon√≠veis
‚Ä¢ 'sair' - Encerrar sess√£o

üëâ **Como posso ajudar na gest√£o escolar hoje?**
"""

    def show_manual_menu(self) -> str:
        """Mostra menu manual de fun√ß√µes"""
        return """
üìã **MENU DE FUN√á√ïES DISPON√çVEIS:**

üîç **AN√ÅLISE E IDENTIFICA√á√ÉO:**
1. Identificar respons√°veis n√£o cadastrados
2. Analisar estat√≠sticas do extrato PIX
3. Listar pagamentos n√£o identificados

üë• **CONSULTAS:**
4. Listar respons√°veis
5. Listar alunos
6. Listar turmas
7. Buscar aluno por nome

üìù **CADASTROS:**
8. Cadastrar respons√°vel
9. Vincular aluno a respons√°vel

üöÄ **PROCESSAMENTO:**
10. Processar respons√°veis do extrato automaticamente

Digite o n√∫mero da fun√ß√£o ou use comandos em linguagem natural.
"""

    def execute_manual_function(self, choice: str) -> str:
        """Executa fun√ß√£o manual baseada na escolha do usu√°rio"""
        try:
            choice = choice.strip()
            
            if choice == "1":
                resultado = executar_function("identificar_responsaveis_nao_cadastrados")
                return self.format_response_for_display(resultado, "identificar_responsaveis_nao_cadastrados")
            
            elif choice == "2":
                resultado = executar_function("analisar_estatisticas_extrato")
                return self.format_response_for_display(resultado, "analisar_estatisticas_extrato")
            
            elif choice == "3":
                resultado = executar_function("listar_pagamentos_nao_identificados", formato_resumido=True)
                return self.format_response_for_display(resultado, "listar_pagamentos_nao_identificados")
            
            elif choice == "4":
                nome = input("üîç Nome para filtrar (deixe vazio para todos): ").strip()
                if nome:
                    resultado = executar_function("listar_responsaveis", filtro_nome=nome)
                else:
                    resultado = executar_function("listar_responsaveis")
                return self.format_response_for_display(resultado, "listar_responsaveis")
            
            elif choice == "5":
                print("üîç Filtros dispon√≠veis:")
                nome = input("Nome do aluno (deixe vazio para ignorar): ").strip()
                turma = input("Turma (deixe vazio para ignorar): ").strip()
                sem_matricula = input("Mostrar apenas sem data de matr√≠cula? (s/n): ").strip().lower() == 's'
                
                filtros = {}
                if nome:
                    filtros["filtro_nome"] = nome
                if turma:
                    filtros["filtro_turma"] = turma
                if sem_matricula:
                    filtros["sem_data_matricula"] = True
                
                resultado = executar_function("listar_alunos", **filtros)
                return self.format_response_for_display(resultado, "listar_alunos")
            
            elif choice == "6":
                resultado = executar_function("listar_turmas")
                return self.format_response_for_display(resultado, "listar_turmas")
            
            elif choice == "7":
                nome = input("üîç Nome do aluno para buscar: ").strip()
                if not nome:
                    return "‚ùå Nome √© obrigat√≥rio para busca"
                resultado = executar_function("buscar_aluno_por_nome", nome=nome)
                return self.format_response_for_display(resultado, "buscar_aluno_por_nome")
            
            elif choice == "8":
                nome = input("üìù Nome completo do respons√°vel: ").strip()
                if not nome:
                    return "‚ùå Nome √© obrigat√≥rio"
                
                cpf = input("CPF (opcional): ").strip() or None
                telefone = input("Telefone (opcional): ").strip() or None
                email = input("Email (opcional): ").strip() or None
                endereco = input("Endere√ßo (opcional): ").strip() or None
                tipo_relacao = input("Tipo de rela√ß√£o (pai, m√£e, av√¥, etc.): ").strip() or None
                
                resultado = executar_function("cadastrar_responsavel_completo",
                                            nome=nome, cpf=cpf, telefone=telefone,
                                            email=email, endereco=endereco, tipo_relacao=tipo_relacao)
                return self.format_response_for_display(resultado, "cadastrar_responsavel_completo")
            
            elif choice == "9":
                id_aluno = input("üìù ID do aluno: ").strip()
                id_responsavel = input("ID do respons√°vel: ").strip()
                tipo_relacao = input("Tipo de rela√ß√£o (pai, m√£e, etc.): ").strip()
                
                if not id_aluno or not id_responsavel:
                    return "‚ùå ID do aluno e respons√°vel s√£o obrigat√≥rios"
                
                resultado = executar_function("vincular_aluno_responsavel",
                                            id_aluno=id_aluno, id_responsavel=id_responsavel,
                                            tipo_relacao=tipo_relacao, responsavel_financeiro=True)
                return self.format_response_for_display(resultado, "vincular_aluno_responsavel")
            
            elif choice == "10":
                print("üöÄ ATEN√á√ÉO: Isso ir√° cadastrar automaticamente todos os respons√°veis n√£o cadastrados do extrato PIX!")
                confirmacao = input("Confirma? (s/n): ").strip().lower()
                if confirmacao == 's':
                    resultado = executar_function("processar_responsaveis_extrato_pix")
                    return self.format_response_for_display(resultado, "processar_responsaveis_extrato_pix")
                else:
                    return "‚ùå Opera√ß√£o cancelada pelo usu√°rio"
            
            else:
                return "‚ùå Op√ß√£o inv√°lida. Digite 'menu' para ver as op√ß√µes dispon√≠veis."
                
        except Exception as e:
            return f"‚ùå Erro ao executar fun√ß√£o: {str(e)}"

    def format_response_for_display(self, resultado: Dict[str, Any], function_name: str) -> str:
        """Formata resposta para exibi√ß√£o amig√°vel"""
        try:
            if resultado.get("status") == "erro" or not resultado.get("success", True):
                return f"‚ùå Erro: {resultado.get('erro', resultado.get('error', 'Erro desconhecido'))}"
            
            # Formata√ß√£o espec√≠fica por fun√ß√£o
            if function_name == "identificar_responsaveis_nao_cadastrados":
                count = resultado.get("count", 0)
                detalhes = resultado.get("detalhes", [])
                if count == 0:
                    return "‚úÖ Todos os respons√°veis do extrato PIX j√° est√£o cadastrados!"
                
                resposta = f"üìä **{count} RESPONS√ÅVEIS N√ÉO CADASTRADOS ENCONTRADOS:**\n\n"
                for i, detalhe in enumerate(detalhes[:20], 1):  # Limita a 20
                    nome = detalhe.get("nome", "Nome n√£o dispon√≠vel")
                    qtd = detalhe.get("quantidade_pagamentos", 0)
                    valor = detalhe.get("valor_total", 0)
                    resposta += f"{i:2d}. {nome}\n"
                    resposta += f"    üìÑ {qtd} pagamento(s) ‚Ä¢ üí∞ R$ {valor:.2f}\n\n"
                
                if count > 20:
                    resposta += f"... e mais {count - 20} respons√°veis\n\n"
                
                resposta += "üí° **Dica:** Use 'processar respons√°veis automaticamente' para cadastr√°-los"
                return resposta
            
            elif function_name == "analisar_estatisticas_extrato":
                stats = resultado.get("estatisticas", {})
                total = stats.get("total_registros", 0)
                identificados = stats.get("total_identificados", 0)
                percentual = stats.get("percentual_identificacao", 0)
                valor_total = stats.get("valor_total", 0)
                valor_nao_identificado = stats.get("valor_nao_identificado", 0)
                
                return f"""üìä **ESTAT√çSTICAS DO EXTRATO PIX:**

üìà **Registros:**
‚Ä¢ Total de registros: {total:,}
‚Ä¢ Identificados: {identificados:,}
‚Ä¢ Percentual identificado: {percentual:.1f}%

üí∞ **Valores:**
‚Ä¢ Valor total: R$ {valor_total:,.2f}
‚Ä¢ Valor identificado: R$ {(valor_total - valor_nao_identificado):,.2f}
‚Ä¢ Valor n√£o identificado: R$ {valor_nao_identificado:,.2f}

üìä **Status:** {'üü¢ Boa identifica√ß√£o' if percentual > 70 else 'üü° Identifica√ß√£o m√©dia' if percentual > 40 else 'üî¥ Baixa identifica√ß√£o'}"""
            
            elif function_name == "processar_responsaveis_extrato_pix":
                total_cadastrados = resultado.get("total_cadastrados", 0)
                if total_cadastrados == 0:
                    return "‚ÑπÔ∏è Nenhum respons√°vel novo foi cadastrado (todos j√° estavam no sistema)"
                
                return f"üöÄ **{total_cadastrados} respons√°veis cadastrados com sucesso!**\nüí° Execute 'analisar estat√≠sticas' para ver o novo status!"
            
            # Formata√ß√£o gen√©rica para outras fun√ß√µes
            else:
                count = resultado.get("count", len(resultado.get("data", [])))
                return f"‚úÖ Opera√ß√£o executada com sucesso!\nüìä {count} registro(s) processado(s)"
        
        except Exception as e:
            return f"‚ùå Erro ao formatar resposta: {str(e)}"

    def send_message_to_ai(self, user_message: str) -> str:
        """Envia mensagem para IA e processa resposta"""
        if not self.use_ai:
            return "‚ùå IA n√£o dispon√≠vel. Use comandos manuais ou configure OPENAI_API_KEY"
        
        try:
            # Adiciona mensagem do usu√°rio ao hist√≥rico
            self.add_to_history("user", user_message)
            
            # Prepara mensagens para a API incluindo hist√≥rico
            messages = [{"role": "system", "content": SYSTEM_PROMPT}]
            messages.extend(self.conversation_history)
            
            # Faz chamada para OpenAI
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=messages,
                tools=self.tools,
                tool_choice="auto",
                temperature=0.2,  # Reduzido para mais consist√™ncia
                max_tokens=4000
            )
            
            return self.handle_ai_response(response)
                
        except Exception as e:
            return f"‚ùå Erro na comunica√ß√£o com IA: {str(e)}"

    def handle_ai_response(self, response) -> str:
        """Trata resposta da IA"""
        try:
            message = response.choices[0].message
            
            # Resposta sem tool calls
            if not message.tool_calls:
                response_content = message.content
                self.add_to_history("assistant", response_content)
                return response_content
            
            # Resposta com tool calls
            return self.handle_tool_calls(message)
            
        except Exception as e:
            return f"‚ùå Erro ao processar resposta da IA: {str(e)}"

    def handle_tool_calls(self, message) -> str:
        """Trata chamadas de fun√ß√µes da IA seguindo o padr√£o OpenAI Function Calling"""
        try:
            # Adiciona mensagem do assistente com tool calls ao hist√≥rico
            tool_calls_data = []
            for tool_call in message.tool_calls:
                tool_calls_data.append({
                    "id": tool_call.id,
                    "type": "function",
                    "function": {
                        "name": tool_call.function.name,
                        "arguments": tool_call.function.arguments
                    }
                })
            
            assistant_message = {
                "role": "assistant",
                "content": None,
                "tool_calls": tool_calls_data
            }
            self.conversation_history.append(assistant_message)
            
            # Execu√ß√£o das fun√ß√µes
            print(f"üîß Executando {len(message.tool_calls)} fun√ß√£o(√µes)...")
            
            for tool_call in message.tool_calls:
                function_name = tool_call.function.name
                
                try:
                    arguments = json.loads(tool_call.function.arguments)
                    print(f"‚ö° Executando: {function_name}")
                    
                    # Execu√ß√£o da fun√ß√£o
                    function_response = executar_function(function_name, **arguments)
                    
                    # Adiciona resultado como mensagem tool ao hist√≥rico
                    tool_message = {
                        "role": "tool",
                        "tool_call_id": tool_call.id,
                        "name": function_name,
                        "content": json.dumps(function_response, ensure_ascii=False, default=str)
                    }
                    self.conversation_history.append(tool_message)
                    
                    print(f"‚úÖ {function_name} executada")
                    
                except Exception as e:
                    error_response = {"erro": f"Erro na fun√ß√£o {function_name}: {str(e)}"}
                    tool_message = {
                        "role": "tool",
                        "tool_call_id": tool_call.id,
                        "name": function_name,
                        "content": json.dumps(error_response, ensure_ascii=False, default=str)
                    }
                    self.conversation_history.append(tool_message)
                    print(f"‚ùå Erro em {function_name}: {str(e)}")
            
            # Solicita resposta final da IA baseada nos resultados
            try:
                follow_up_response = client.chat.completions.create(
                    model="gpt-4o",
                    messages=[{"role": "system", "content": SYSTEM_PROMPT}] + self.conversation_history[-20:],
                    temperature=0.2,
                    max_tokens=4000
                )
                
                final_content = follow_up_response.choices[0].message.content
                self.add_to_history("assistant", final_content)
                
                return final_content
                
            except Exception as api_error:
                print(f"‚ö†Ô∏è Erro na IA ap√≥s executar fun√ß√µes: {str(api_error)}")
                
                # Recupera√ß√£o manual - cria resposta baseada nos resultados
                recovery_message = "‚úÖ **Fun√ß√µes executadas com sucesso!**\n\n"
                recovery_message += "üí° Use 'estatisticas' ou 'identificar' para verificar os resultados.\n"
                recovery_message += "üìù Posso ajudar com mais alguma opera√ß√£o?"
                
                self.add_to_history("assistant", recovery_message)
                return recovery_message
                
        except Exception as e:
            return f"‚ùå Erro ao processar chamadas de fun√ß√£o: {str(e)}"

    def show_help(self) -> str:
        """Mostra comandos de ajuda"""
        ai_commands = """
ü§ñ **COMANDOS COM IA:**
‚Ä¢ "Liste respons√°veis n√£o cadastrados no extrato PIX"
‚Ä¢ "Mostre alunos da turma Infantil III sem data de matr√≠cula"
‚Ä¢ "Cadastre respons√°vel Jo√£o Silva como pai da aluna Maria Silva"
‚Ä¢ "Analise estat√≠sticas do extrato PIX e sugira a√ß√µes"
‚Ä¢ "Processe automaticamente todos os respons√°veis n√£o identificados"
‚Ä¢ "Mostre respons√°veis com nome Silva"
‚Ä¢ "Liste alunos sem valor de mensalidade definido"
""" if self.use_ai else ""
        
        return f"""
üÜò **COMANDOS DISPON√çVEIS:**
{ai_commands}
üìã **COMANDOS MANUAIS:**
‚Ä¢ 'menu' - Menu de fun√ß√µes dispon√≠veis
‚Ä¢ 'identificar' - Respons√°veis n√£o cadastrados
‚Ä¢ 'estatisticas' - An√°lise do extrato PIX
‚Ä¢ 'responsaveis' - Listar respons√°veis
‚Ä¢ 'alunos' - Listar alunos
‚Ä¢ 'turmas' - Listar turmas dispon√≠veis

üîß **UTILIT√ÅRIOS:**
‚Ä¢ 'ajuda' / 'help' - Esta mensagem
‚Ä¢ 'sair' / 'exit' - Encerrar sess√£o
‚Ä¢ 'limpar' - Limpar hist√≥rico de conversa

üí° **Dicas:**
- Use linguagem natural com a IA
- Combine m√∫ltiplas opera√ß√µes em uma solicita√ß√£o
- Seja espec√≠fico com filtros e crit√©rios
"""

    def run(self):
        """Loop principal da aplica√ß√£o"""
        print(self.format_welcome_message())
        
        while True:
            try:
                user_input = input("\nüí¨ Voc√™: ").strip()
                
                # Comandos especiais
                if user_input.lower() in ["sair", "exit", "quit"]:
                    print("\nüëã Encerrando sess√£o. At√© logo!")
                    break
                    
                elif user_input.lower() in ["ajuda", "help"]:
                    print(self.show_help())
                    continue
                    
                elif user_input.lower() == "menu":
                    print(self.show_manual_menu())
                    continue
                
                elif user_input.lower() in ["identificar", "1"]:
                    print("\nüîÑ Processando...")
                    response = self.execute_manual_function("1")
                    print(f"\nüìä Resultado:\n{response}")
                    continue
                
                elif user_input.lower() in ["estatisticas", "2"]:
                    print("\nüîÑ Processando...")
                    response = self.execute_manual_function("2")
                    print(f"\nüìä Resultado:\n{response}")
                    continue
                
                elif user_input.isdigit() and 1 <= int(user_input) <= 10:
                    print("\nüîÑ Processando...")
                    response = self.execute_manual_function(user_input)
                    print(f"\nüìä Resultado:\n{response}")
                    continue
                    
                elif not user_input:
                    print("üí≠ Por favor, digite uma pergunta, comando ou n√∫mero do menu.")
                    continue
                
                # Processamento com IA ou manual
                print("\nüîÑ Processando...")
                if self.use_ai:
                    response = self.send_message_to_ai(user_input)
                else:
                    response = "ü§ñ IA n√£o dispon√≠vel. Use 'menu' para fun√ß√µes manuais ou configure OPENAI_API_KEY."
                
                print(f"\nü§ñ Assistente:\n{response}")
                
            except KeyboardInterrupt:
                print("\n\nüëã Encerrando por interrup√ß√£o. At√© logo!")
                break
            except Exception as e:
                print(f"\n‚ùå Erro inesperado: {str(e)}")
                continue

# ==========================================================
# üöÄ Fun√ß√£o Principal
# ==========================================================

def main():
    """Fun√ß√£o principal"""
    try:
        print("üéì Inicializando Assistente Escolar IA...")
        
        assistente = AssistenteEscolarIA(use_ai=True)
        assistente.run()
        
    except Exception as e:
        print(f"‚ùå Erro fatal: {str(e)}")

if __name__ == "__main__":
    main()
